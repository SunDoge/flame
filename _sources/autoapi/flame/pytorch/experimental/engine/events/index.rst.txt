:mod:`flame.pytorch.experimental.engine.events`
===============================================

.. py:module:: flame.pytorch.experimental.engine.events


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   flame.pytorch.experimental.engine.events.CallableEventWithFilter
   flame.pytorch.experimental.engine.events.EventEnum
   flame.pytorch.experimental.engine.events.Events
   flame.pytorch.experimental.engine.events.EventsList
   flame.pytorch.experimental.engine.events.State



Functions
~~~~~~~~~

.. autoapisummary::

   flame.pytorch.experimental.engine.events._get_default_event_to_attr



Attributes
~~~~~~~~~~

.. autoapisummary::

   flame.pytorch.experimental.engine.events._logger


.. data:: _logger
   

   

.. class:: CallableEventWithFilter(value, event_filter = None, name = None)


   Single Event containing a filter, specifying whether the event should
   be run at the current event (if the event type is correct)

   :param value: The actual enum value. Only needed for internal use. Do not touch!
   :param event_filter: A function taking the engine and the current event value as input and returning a
                        boolean to indicate whether this event should be executed. Defaults to None, which will result to a
                        function that always returns `True`
   :param name: The enum-name of the current object. Only needed for internal use. Do not touch!

   .. method:: name(self)

      The name of the Enum member.


   .. method:: value(self)

      The value of the Enum member.


   .. method:: __call__(self, event_filter = None, every = None, once = None)

      Makes the event class callable and accepts either an arbitrary callable as filter
      (which must take in the engine and current event value and return a boolean) or an every or once value

      :param event_filter: a filter function to check if the event should be executed when
                           the event type was fired
      :param every: a value specifying how often the event should be fired
      :param once: a value specifying when the event should be fired (if only once)

      :returns: A new event having the same value but a different filter function
      :rtype: CallableEventWithFilter


   .. method:: every_event_filter(every)
      :staticmethod:

      A wrapper for every event filter.


   .. method:: once_event_filter(once)
      :staticmethod:

      A wrapper for once event filter.


   .. method:: default_event_filter(engine, event)
      :staticmethod:

      Default event filter.


   .. method:: __str__(self)

      Return str(self).


   .. method:: __eq__(self, other)

      Return self==value.


   .. method:: __hash__(self)

      Return hash(self).


   .. method:: __or__(self, other)



.. class:: EventEnum(value, event_filter = None, name = None)


   Bases: :py:obj:`CallableEventWithFilter`, :py:obj:`enum.Enum`

   Base class for all :class:`~ignite.engine.events.Events`. User defined custom events should also inherit
   this class. For example, Custom events based on the loss calculation and backward pass can be created as follows:

       .. code-block:: python

           from ignite.engine import EventEnum

           class BackpropEvents(EventEnum):
               BACKWARD_STARTED = 'backward_started'
               BACKWARD_COMPLETED = 'backward_completed'
               OPTIM_STEP_COMPLETED = 'optim_step_completed'

           def update(engine, batch):
               # ...
               loss = criterion(y_pred, y)
               engine.fire_event(BackpropEvents.BACKWARD_STARTED)
               loss.backward()
               engine.fire_event(BackpropEvents.BACKWARD_COMPLETED)
               optimizer.step()
               engine.fire_event(BackpropEvents.OPTIM_STEP_COMPLETED)
               # ...

           trainer = Engine(update)
           trainer.register_events(*BackpropEvents)

           @trainer.on(BackpropEvents.BACKWARD_STARTED)
           def function_before_backprop(engine):
               # ...


.. class:: Events(value, event_filter = None, name = None)


   Bases: :py:obj:`EventEnum`

   Base class for all :class:`~ignite.engine.events.Events`. User defined custom events should also inherit
   this class. For example, Custom events based on the loss calculation and backward pass can be created as follows:

       .. code-block:: python

           from ignite.engine import EventEnum

           class BackpropEvents(EventEnum):
               BACKWARD_STARTED = 'backward_started'
               BACKWARD_COMPLETED = 'backward_completed'
               OPTIM_STEP_COMPLETED = 'optim_step_completed'

           def update(engine, batch):
               # ...
               loss = criterion(y_pred, y)
               engine.fire_event(BackpropEvents.BACKWARD_STARTED)
               loss.backward()
               engine.fire_event(BackpropEvents.BACKWARD_COMPLETED)
               optimizer.step()
               engine.fire_event(BackpropEvents.OPTIM_STEP_COMPLETED)
               # ...

           trainer = Engine(update)
           trainer.register_events(*BackpropEvents)

           @trainer.on(BackpropEvents.BACKWARD_STARTED)
           def function_before_backprop(engine):
               # ...

   .. attribute:: EPOCH_STARTED
      :annotation: = epoch_started

      

   .. attribute:: EPOCH_COMPLETED
      :annotation: = epoch_completed

      

   .. attribute:: STARTED
      :annotation: = started

      

   .. attribute:: COMPLETED
      :annotation: = completed

      

   .. attribute:: ITERATION_STARTED
      :annotation: = iteration_started

      

   .. attribute:: ITERATION_COMPLETED
      :annotation: = iteration_completed

      

   .. attribute:: EXCEPTION_RAISED
      :annotation: = exception_raised

      

   .. attribute:: GET_BATCH_STARTED
      :annotation: = get_batch_started

      

   .. attribute:: GET_BATCH_COMPLETED
      :annotation: = get_batch_completed

      

   .. attribute:: DATALOADER_STOP_ITERATION
      :annotation: = dataloader_stop_iteration

      

   .. attribute:: TERMINATE
      :annotation: = terminate

      

   .. attribute:: TERMINATE_SINGLE_EPOCH
      :annotation: = terminate_single_epoch

      

   .. method:: __or__(self, other)



.. class:: EventsList


   .. method:: _append(self, event)


   .. method:: __getitem__(self, index)


   .. method:: __iter__(self)


   .. method:: __len__(self)


   .. method:: __or__(self, other)



.. function:: _get_default_event_to_attr()


.. class:: State

   .. attribute:: epoch
      :annotation: :int = 0

      

   .. attribute:: max_epochs
      :annotation: :Optional[int]

      

   .. attribute:: local_iteration
      :annotation: :int = 0

      

   .. attribute:: global_iteration
      :annotation: :int = 0

      

   .. attribute:: epoch_length
      :annotation: :Optional[int]

      

   .. attribute:: max_iterations
      :annotation: :Optional[int]

      

   .. attribute:: batch
      :annotation: :Optional[Any]

      

   .. attribute:: output
      :annotation: :Optional[Any]

      

   .. attribute:: dataloader
      :annotation: :Optional[Iterable[Any]]

      

   .. attribute:: metrics
      :annotation: :Dict[str, Any]

      

   .. attribute:: event_to_attr
      :annotation: :Dict[Events, str]

      

   .. method:: update_max_iterations(self)


   .. method:: update_local_iteration(self, iteration)


   .. method:: update_global_iteration(self)


   .. method:: is_done_iterations(self)


   .. method:: is_done_epochs(self)


   .. method:: is_done_count(self)


   .. method:: is_done(self)


   .. method:: reset(self)


   .. method:: every_iterations(self, n)


   .. method:: every_epochs(self, n)


   .. method:: _update_attrs(self)


   .. method:: get_event_attrib_value(self, event_name)

      Get the value of Event attribute with given `event_name`.



