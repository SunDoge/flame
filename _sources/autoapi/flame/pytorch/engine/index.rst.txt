:mod:`flame.pytorch.engine`
===========================

.. py:module:: flame.pytorch.engine


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   flame.pytorch.engine.Engine
   flame.pytorch.engine.A



.. class:: Engine(process_function: Callable, injector: Optional[Injector] = None)


   Bases: :class:`ignite.engine.Engine`

   Runs a given ``process_function`` over each batch of a dataset, emitting events as it goes.

   :param process_function: A function receiving a handle to the engine and the current batch
                            in each iteration, and returns data to be stored in the engine's state.

   .. attribute:: state

      object that is used to pass internal and user-defined state between event handlers.
      It is created with the engine and its attributes (e.g. ``state.iteration``, ``state.epoch`` etc) are reset
      on every :meth:`~ignite.engine.engine.Engine.run`.

   .. attribute:: last_event_name

      last event name triggered by the engine.

   .. rubric:: Examples

   Create a basic trainer

   .. code-block:: python

       def update_model(engine, batch):
           inputs, targets = batch
           optimizer.zero_grad()
           outputs = model(inputs)
           loss = criterion(outputs, targets)
           loss.backward()
           optimizer.step()
           return loss.item()

       trainer = Engine(update_model)

       @trainer.on(Events.ITERATION_COMPLETED(every=100))
       def log_training(engine):
           batch_loss = engine.state.output
           lr = optimizer.param_groups[0]['lr']
           e = engine.state.epoch
           n = engine.state.max_epochs
           i = engine.state.iteration
           print(f"Epoch {e}/{n} : {i} - batch loss: {batch_loss}, lr: {lr}")

       trainer.run(data_loader, max_epochs=5)

       > Epoch 1/5 : 100 - batch loss: 0.10874069479016124, lr: 0.01
       > ...
       > Epoch 2/5 : 1700 - batch loss: 0.4217900575859437, lr: 0.01

   Create a basic evaluator to compute metrics

   .. code-block:: python

       from ignite.metrics import Accuracy

       def predict_on_batch(engine, batch)
           model.eval()
           with torch.no_grad():
               x, y = prepare_batch(batch, device=device, non_blocking=non_blocking)
               y_pred = model(x)

           return y_pred, y

       evaluator = Engine(predict_on_batch)
       Accuracy().attach(evaluator, "val_acc")
       evaluator.run(val_dataloader)

   Compute image mean/std on training dataset

   .. code-block:: python

       from ignite.metrics import Average

       def compute_mean_std(engine, batch):
           b, c, *_ = batch['image'].shape
           data = batch['image'].reshape(b, c, -1).to(dtype=torch.float64)
           mean = torch.mean(data, dim=-1).sum(dim=0)
           mean2 = torch.mean(data ** 2, dim=-1).sum(dim=0)
           return {"mean": mean, "mean^2": mean2}

       compute_engine = Engine(compute_mean_std)
       img_mean = Average(output_transform=lambda output: output['mean'])
       img_mean.attach(compute_engine, 'mean')
       img_mean2 = Average(output_transform=lambda output: output['mean^2'])
       img_mean2.attach(compute_engine, 'mean2')
       state = compute_engine.run(train_loader)
       state.metrics['std'] = torch.sqrt(state.metrics['mean2'] - state.metrics['mean'] ** 2)
       mean = state.metrics['mean'].tolist()
       std = state.metrics['std'].tolist()

   Resume engine's run from a state. User can load a `state_dict` and run engine starting from loaded state :

   .. code-block:: python

       # Restore from an epoch
       state_dict = {"epoch": 3, "max_epochs": 100, "epoch_length": len(data_loader)}
       # or an iteration
       # state_dict = {"iteration": 500, "max_epochs": 100, "epoch_length": len(data_loader)}

       trainer = Engine(...)
       trainer.load_state_dict(state_dict)
       trainer.run(data)

   .. method:: with_engine(process_function_without_engine: Callable) -> Callable
      :staticmethod:

      Helper function


   .. method:: add_event_handler(self, event_name: Any, handler: Callable, *args: Any, **kwargs: Any) -> ignite.engine.RemovableEventHandle

      Add an event handler to be executed when the specified event is fired.

      :param event_name: An event or a list of events to attach the handler. Valid events are
                         from :class:`~ignite.engine.events.Events` or any ``event_name`` added by
                         :meth:`~ignite.engine.engine.Engine.register_events`.
      :param handler: the callable event handler that should be invoked. No restrictions on its signature.
                      The first argument can be optionally `engine`, the :class:`~ignite.engine.engine.Engine` object,
                      handler is bound to.
      :param args: optional args to be passed to ``handler``.
      :param kwargs: optional keyword args to be passed to ``handler``.

      :returns: :class:`~ignite.engine.events.RemovableEventHandle`, which can be used to remove the handler.

      .. note::

         Note that other arguments can be passed to the handler in addition to the `*args` and  `**kwargs`
         passed here, for example during :attr:`~ignite.engine.events.Events.EXCEPTION_RAISED`.

      Example usage:

      .. code-block:: python

          engine = Engine(process_function)

          def print_epoch(engine):
              print(f"Epoch: {engine.state.epoch}")

          engine.add_event_handler(Events.EPOCH_COMPLETED, print_epoch)

          events_list = Events.EPOCH_COMPLETED | Events.COMPLETED

          def execute_something():
              # do some thing not related to engine
              pass

          engine.add_event_handler(events_list, execute_something)

      .. note::

         Since v0.3.0, Events become more flexible and allow to pass an event filter to the Engine.
         See :class:`~ignite.engine.events.Events` for more details.


   .. method:: _fire_event(self, event_name: Any, *event_args: Any, **event_kwargs: Any) -> None

      Execute all the handlers associated with given event.

      This method executes all handlers associated with the event
      `event_name`. Optional positional and keyword arguments can be used to
      pass arguments to **all** handlers added with this event. These
      arguments updates arguments passed using :meth:`~ignite.engine.engine.Engine.add_event_handler`.

      :param event_name: event for which the handlers should be executed. Valid
                         events are from :class:`~ignite.engine.events.Events` or any `event_name` added by
                         :meth:`~ignite.engine.engine.Engine.register_events`.
      :param \*event_args: optional args to be passed to all handlers.
      :param \*\*event_kwargs: optional keyword args to be passed to all handlers.



.. class:: A



